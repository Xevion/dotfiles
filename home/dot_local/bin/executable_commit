#!/usr/bin/env bun

import { defineCommand, runMain } from "citty";
import * as p from "@clack/prompts";
import { SelectPrompt } from "@clack/core";
import pc from "picocolors";
import { execSync, spawnSync, spawn as cpSpawn } from "child_process";
import { readFileSync } from "fs";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

type Backend = "claude" | "opencode";
type ModelAlias = "haiku" | "sonnet" | "opus";
type ThinkingLevel = "minimal" | "high" | "max";
type PostAction = "commit" | "edit" | "tweak";

interface CommitOption {
  subject: string;
  body?: string;
}

/** Default thinking level per model (opencode only). */
const THINKING_DEFAULTS: Record<ModelAlias, ThinkingLevel> = {
  haiku: "high",
  sonnet: "minimal",
  opus: "minimal",
};

/** Refinement presets for regeneration. */
const REFINEMENT_PRESETS: Array<{ value: string; label: string }> = [
  { value: "none", label: "Just regenerate (no guidance)" },
  { value: "concise", label: "More concise" },
  { value: "detailed", label: "More detailed" },
  { value: "prefix", label: "Different prefix/scope" },
  { value: "conventional", label: "More conventional style" },
  { value: "custom", label: "Custom feedback..." },
];

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function isCancel(value: unknown): value is symbol {
  return p.isCancel(value);
}

function bail(msg?: string): never {
  p.cancel(msg ?? "Cancelled.");
  process.exit(1);
}

/** Run a shell command and return trimmed stdout, or null on failure. */
function shell(cmd: string): string | null {
  try {
    return execSync(cmd, { encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"] }).trim();
  } catch {
    return null;
  }
}

/** Check whether there are staged changes. */
function hasStagedChanges(): boolean {
  const result = spawnSync("git", ["diff", "--cached", "--quiet"], { stdio: "pipe" });
  // exit code 1 = there ARE changes, 0 = no changes
  return result.status === 1;
}

/** Gather context via commit-helper. */
function gatherDiffContext(): string {
  const out = shell("commit-helper --staged");
  if (!out) {
    p.log.error("Failed to gather staged changes via commit-helper.");
    bail();
  }
  return out;
}

// ---------------------------------------------------------------------------
// System prompt (embedded commit-style rules)
// ---------------------------------------------------------------------------

function buildSystemPrompt(count: number): string {
  return `You are a commit message generator. You will be given a diff of staged changes and optional context from the developer.

Your task: produce exactly ${count} commit message options.

## CRITICAL: Match the existing commit style EXACTLY

The input includes a "Recent Commit Style" section showing the repository's actual recent commits.
This section is your PRIMARY source of truth. You MUST replicate the exact formatting conventions you see there.

Before writing ANY option, analyze the recent commits and answer these questions internally:
1. Do they use a prefix like "type: description"? If yes, EVERY option you generate MUST use a prefix.
2. What prefix types appear? (e.g. feat, fix, config, refactor, docs) Use only prefixes that appear in the history or are semantically appropriate for the change.
3. What comes after the prefix — lowercase or capitalized? Match it.
4. How long are the messages? Match that level of detail.

If the recent commits use conventional commit style (e.g. "feat:", "fix:", "config:"), then ALL ${count} of your options MUST use a prefix. Never mix prefixed and unprefixed styles.

## Formatting rules

- Subject line under 72 characters
- Imperative mood ("add", "fix", "refactor", not "added", "fixes")
- No trailing periods on subject lines
- Single-line subject for most commits
- Add a body (separated by blank line) ONLY for genuinely complex changes
- Focus on WHAT changed and WHY, not implementation details
- NEVER mention: test results, lockfile changes, file counts, build status

## Output format

Respond with EXACTLY this format and nothing else — no commentary, no markdown fences, no preamble:

1: <subject line>
[optional body paragraph]

2: <subject line>
[optional body paragraph]

...

${count}: <subject line>
[optional body paragraph]

Each option starts with its number prefix on a new line. The body, if present, is separated from the subject by one blank line and should be wrapped at 72 characters.`;
}

// ---------------------------------------------------------------------------
// AI invocation
// ---------------------------------------------------------------------------

/** Map model alias to the string each backend expects. */
function modelFlag(backend: Backend, alias: ModelAlias): string {
  if (backend === "claude") {
    return alias; // claude CLI accepts "haiku", "sonnet", "opus" directly
  }
  // opencode wants "provider/model-version" format
  const map: Record<ModelAlias, string> = {
    haiku: "anthropic/claude-haiku-4-5",
    sonnet: "anthropic/claude-sonnet-4-6",
    opus: "anthropic/claude-opus-4-6",
  };
  return map[alias];
}

/** Build the user prompt from diff context + optional developer context + refinement. */
function buildUserPrompt(
  diffContext: string,
  userContext: string,
  count: number,
  refinement?: string,
): string {
  let prompt = diffContext;
  if (userContext.trim()) {
    prompt += `\n\n## Developer Context\n\n${userContext.trim()}`;
  }
  if (refinement) {
    prompt += `\n\n## Refinement Request\n\n${refinement}`;
  }
  prompt += `\n\nGenerate exactly ${count} commit message options in the specified format.`;
  return prompt;
}

/** Write content to a temp file and return the path. */
function writeTempFile(prefix: string, content: string): string {
  const path = `/tmp/${prefix}-${Date.now()}.txt`;
  require("fs").writeFileSync(path, content, "utf-8");
  return path;
}

/** Clean up temp files, ignoring errors. */
function removeTempFile(path: string): void {
  try { require("fs").unlinkSync(path); } catch { /* ignore */ }
}

/** Invoke an AI backend asynchronously, returning stdout. */
function invokeAI(
  backend: Backend,
  model: ModelAlias,
  diffContext: string,
  userContext: string,
  count: number,
  variant?: string,
  refinement?: string,
): Promise<string> {
  const systemPrompt = buildSystemPrompt(count);
  const userPrompt = buildUserPrompt(diffContext, userContext, count, refinement);
  const m = modelFlag(backend, model);

  if (backend === "claude") {
    return spawnAsync(
      "claude",
      ["--print", "--model", m, "--output-format", "json", "--system-prompt", systemPrompt, "--tools", ""],
      userPrompt,
    ).then((raw) => {
      try {
        const parsed = JSON.parse(raw);
        return parsed.result ?? raw;
      } catch {
        return raw;
      }
    });
  }

  // opencode has no --system-prompt flag — combine system+user into a temp file
  const fullPrompt = `${systemPrompt}\n\n---\n\n${userPrompt}`;
  const promptFile = writeTempFile("commit-prompt", fullPrompt);

  const opencodeArgs = ["run", "--model", m, "--format", "json", "-f", promptFile];
  if (variant) opencodeArgs.push("--variant", variant);

  return spawnAsync(
    "opencode",
    opencodeArgs,
    `Follow the attached file exactly. Generate ${count} commit message options.`,
  ).then((raw) => {
    // opencode JSON is NDJSON — extract text from "type":"text" events
    try {
      const textParts: string[] = [];
      for (const line of raw.split("\n")) {
        if (!line.trim()) continue;
        const event = JSON.parse(line);
        if (event.type === "text" && event.part?.text) {
          textParts.push(event.part.text);
        }
      }
      return textParts.join("") || raw;
    } catch {
      return raw;
    }
  }).finally(() => removeTempFile(promptFile));
}

/** Spawn a child process and collect stdout/stderr. Rejects on non-zero exit. */
function spawnAsync(cmd: string, args: string[], stdin?: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const child = cpSpawn(cmd, args, { stdio: ["pipe", "pipe", "pipe"] });

    let stdout = "";
    let stderr = "";

    child.stdout.on("data", (d: Buffer) => { stdout += d.toString(); });
    child.stderr.on("data", (d: Buffer) => { stderr += d.toString(); });

    child.on("error", (err) => reject(err));
    child.on("close", (code) => {
      clearTimeout(timeout);
      if (code !== 0) {
        reject(new Error(`${cmd} exited ${code}: ${stderr.trim() || "unknown error"}`));
      } else {
        resolve(stdout.trim());
      }
    });

    if (stdin) {
      child.stdin.write(stdin);
      child.stdin.end();
    } else {
      child.stdin.end();
    }

    const timeout = setTimeout(() => {
      child.kill("SIGTERM");
      reject(new Error(`${cmd} timed out after 120s`));
    }, 120_000);
  });
}

// ---------------------------------------------------------------------------
// Parsing AI output
// ---------------------------------------------------------------------------

/**
 * Parse the AI's numbered response into CommitOption[].
 * Expected format:
 *   1: subject line
 *   optional body
 *
 *   2: subject line
 *   ...
 */
function parseOptions(raw: string): CommitOption[] {
  const options: CommitOption[] = [];

  // Strip any preamble before the first numbered option
  const firstOption = raw.search(/^\d+:\s/m);
  if (firstOption === -1) return [];
  const cleaned = raw.slice(firstOption);

  // Split on lines starting with "N:" to get each option block
  const parts = cleaned.split(/(?:^|\n)(?=\d+:\s)/);

  for (const part of parts) {
    const trimmed = part.trim();
    if (!trimmed) continue;

    // Remove the leading "N: " prefix
    const withoutPrefix = trimmed.replace(/^\d+:\s*/, "");
    const lines = withoutPrefix.split("\n");
    const subject = lines[0].trim();
    if (!subject) continue;

    // Everything after a blank line separator is the body
    const blankIdx = lines.findIndex((l, i) => i > 0 && l.trim() === "");
    let body: string | undefined;
    if (blankIdx > 0 && blankIdx < lines.length - 1) {
      body = lines
        .slice(blankIdx + 1)
        .join("\n")
        .trim();
    }

    options.push({ subject, body });
  }

  return options;
}

/** Convert a CommitOption to the full commit message string. */
function toCommitMessage(opt: CommitOption): string {
  if (opt.body) {
    return `${opt.subject}\n\n${opt.body}`;
  }
  return opt.subject;
}

// ---------------------------------------------------------------------------
// Clack visual constants (matching @clack/prompts style)
// ---------------------------------------------------------------------------

const S_STEP_ACTIVE = "◆";
const S_STEP_SUBMIT = "◇";
const S_STEP_CANCEL = "■";
const S_BAR = "│";
const S_BAR_END = "└";
const S_RADIO_ACTIVE = "●";
const S_RADIO_INACTIVE = "○";

// ---------------------------------------------------------------------------
// Custom multi-line select component
// ---------------------------------------------------------------------------

type CommitSelectValue = number | "regenerate";

interface CommitSelectOption {
  value: CommitSelectValue;
  subject: string;
  body?: string;
  isAction?: boolean;
}

/**
 * Custom select prompt that renders commit messages with full bodies visible.
 * Uses @clack/core's SelectPrompt with a custom render() method.
 */
function commitSelect(
  options: CommitOption[],
): Promise<CommitSelectValue | symbol> {
  const selectOptions: CommitSelectOption[] = [
    ...options.map((opt, i) => ({
      value: i as CommitSelectValue,
      subject: opt.subject,
      body: opt.body,
    })),
    { value: "regenerate" as const, subject: "Regenerate", isAction: true },
  ];

  return new SelectPrompt<CommitSelectOption & { disabled?: boolean }>({
    options: selectOptions.map((o) => ({ ...o, disabled: false })),
    initialValue: 0 as CommitSelectValue,
    render() {
      const state = this.state;

      // Title line
      const icon =
        state === "submit"
          ? pc.green(S_STEP_SUBMIT)
          : state === "cancel"
            ? pc.red(S_STEP_CANCEL)
            : pc.cyan(S_STEP_ACTIVE);
      const bar =
        state === "cancel" ? pc.red(S_BAR) : state === "submit" ? pc.gray(S_BAR) : pc.cyan(S_BAR);

      const title = `${pc.gray(S_BAR)}\n${icon}  Pick a commit message\n`;

      if (state === "submit") {
        const chosen = selectOptions[this.cursor];
        return `${title}${pc.gray(S_BAR)}  ${pc.dim(chosen.subject)}`;
      }

      if (state === "cancel") {
        const chosen = selectOptions[this.cursor];
        return `${title}${pc.gray(S_BAR)}  ${pc.strikethrough(pc.dim(chosen.subject))}\n${pc.gray(S_BAR)}`;
      }

      // Active state — render all options
      const lines: string[] = [];
      for (let i = 0; i < selectOptions.length; i++) {
        const opt = selectOptions[i];
        const active = i === this.cursor;
        const radio = active ? pc.green(S_RADIO_ACTIVE) : pc.dim(S_RADIO_INACTIVE);

        if (opt.isAction) {
          // Regenerate action — styled differently
          const label = active ? pc.yellow(opt.subject) : pc.dim(pc.yellow(opt.subject));
          lines.push(`${bar}  ${radio} ${label}`);
        } else {
          // Commit option — subject + optional body
          const subject = active ? pc.bold(opt.subject) : pc.dim(opt.subject);
          lines.push(`${bar}  ${radio} ${subject}`);

          if (opt.body) {
            // Render body lines indented under the subject
            const bodyLines = opt.body.split("\n");
            for (const bodyLine of bodyLines) {
              lines.push(`${bar}    ${pc.dim(bodyLine)}`);
            }
          }

          // Blank separator between commit options (not after the last one before Regenerate)
          if (i < selectOptions.length - 2 || (opt.body && i < selectOptions.length - 1)) {
            lines.push(`${bar}`);
          }
        }
      }

      return `${title}${lines.join("\n")}\n${pc.cyan(S_BAR_END)}\n`;
    },
  }).prompt() as Promise<CommitSelectValue | symbol>;
}

// ---------------------------------------------------------------------------
// Refinement prompt
// ---------------------------------------------------------------------------

/** Show refinement sub-prompt. Returns a refinement string or undefined. */
async function promptRefinement(): Promise<string | undefined> {
  const picks = await p.multiselect({
    message: "Refine the next generation?",
    options: REFINEMENT_PRESETS.map((r) => ({ value: r.value, label: r.label })),
    required: true,
  });
  if (isCancel(picks)) bail();

  const selected = picks as string[];

  // "none" means no refinement
  if (selected.includes("none")) return undefined;

  const parts: string[] = [];

  for (const pick of selected) {
    if (pick === "custom") continue;
    const preset = REFINEMENT_PRESETS.find((r) => r.value === pick);
    if (preset) parts.push(preset.label);
  }

  // Custom feedback
  if (selected.includes("custom")) {
    const feedback = await p.text({
      message: "What should be different?",
      placeholder: "e.g. focus on the API changes, shorter subject...",
    });
    if (isCancel(feedback)) bail();
    if ((feedback as string).trim()) {
      parts.push((feedback as string).trim());
    }
  }

  if (parts.length === 0) return undefined;

  return `The user wants the next set of options to be:\n${parts.map((p) => `- ${p}`).join("\n")}`;
}

// ---------------------------------------------------------------------------
// Post-selection action prompt
// ---------------------------------------------------------------------------

/** Prompt user for what to do with the selected commit message. */
async function promptPostAction(): Promise<PostAction> {
  const action = await p.select({
    message: "Action",
    options: [
      { value: "commit" as PostAction, label: "Commit", hint: "run git commit" },
      { value: "edit" as PostAction, label: "Edit", hint: "open in $EDITOR" },
      { value: "tweak" as PostAction, label: "Tweak with AI", hint: "use as baseline, regenerate" },
    ],
  });
  if (isCancel(action)) bail();
  return action as PostAction;
}

/** Open a message in $EDITOR and return the edited content. */
function editInEditor(message: string): string {
  const tmpFile = writeTempFile("commit-edit", message);
  const editor = process.env.EDITOR || process.env.VISUAL || "vi";
  spawnSync(editor, [tmpFile], { stdio: "inherit" });
  const edited = readFileSync(tmpFile, "utf-8").trim();
  removeTempFile(tmpFile);
  return edited;
}

// ---------------------------------------------------------------------------
// Git commit
// ---------------------------------------------------------------------------

function runCommit(message: string, dryRun: boolean): void {
  if (dryRun) {
    p.log.info(pc.yellow("Dry run — would commit with:"));
    console.log();
    console.log(pc.bold(message));
    console.log();
    return;
  }

  // Write message to a temp file to avoid shell escaping issues
  const tmpFile = `/tmp/commit-msg-${Date.now()}.txt`;
  Bun.write(tmpFile, message);

  try {
    const result = spawnSync("git", ["commit", "-F", tmpFile], {
      encoding: "utf-8",
      stdio: ["pipe", "pipe", "pipe"],
    });

    if (result.status !== 0) {
      const stderr = result.stderr?.trim() || "";
      const stdout = result.stdout?.trim() || "";
      p.log.error("git commit failed:");
      if (stderr) console.error(stderr);
      if (stdout) console.log(stdout);
      process.exit(result.status ?? 1);
    }

    const stdout = result.stdout?.trim() || "";
    if (stdout) p.log.success(stdout);
  } finally {
    try {
      require("fs").unlinkSync(tmpFile);
    } catch { /* ignore cleanup errors */ }
  }
}

// ---------------------------------------------------------------------------
// Subcommands
// ---------------------------------------------------------------------------

const promptCmd = defineCommand({
  meta: {
    name: "prompt",
    description: "Print the full prompt that would be sent to the AI",
  },
  args: {
    context: {
      type: "string",
      alias: "c",
      description: "Optional developer context to include",
    },
    system: {
      type: "boolean",
      alias: "s",
      description: "Include the system prompt (off by default)",
    },
  },
  run({ args }) {
    if (!hasStagedChanges()) {
      console.error("No staged changes. Stage files with `git add` first.");
      process.exit(1);
    }

    const diffContext = gatherDiffContext();
    const count = 5;
    const userPrompt = buildUserPrompt(diffContext, args.context ?? "", count);

    if (args.system) {
      console.log("=== SYSTEM PROMPT ===\n");
      console.log(buildSystemPrompt(count));
      console.log("\n=== USER PROMPT ===\n");
    }
    console.log(userPrompt);
  },
});

// ---------------------------------------------------------------------------
// Main TUI flow
// ---------------------------------------------------------------------------

const main = defineCommand({
  meta: {
    name: "commit",
    description: "Interactive AI-powered commit message generator",
  },
  subCommands: {
    prompt: promptCmd,
  },
  args: {
    dryRun: {
      type: "boolean",
      alias: "n",
      description: "Preview the commit message without actually committing",
    },
    count: {
      type: "string",
      alias: "N",
      description: "Number of commit message options to generate",
    },
  },
  async run({ args }) {
    const dryRun = args.dryRun;

    p.intro(pc.bgCyan(pc.black(" commit ")));

    // 1. Check staged changes
    if (!hasStagedChanges()) {
      p.log.error("No staged changes. Stage files with " + pc.cyan("git add") + " first.");
      bail();
    }

    // 2. Backend selection
    const backend = await p.select({
      message: "Backend",
      options: [
        { value: "opencode" as Backend, label: "OpenCode", hint: "opencode CLI" },
        { value: "claude" as Backend, label: "Claude Code", hint: "claude CLI" },
      ],
    });
    if (isCancel(backend)) bail();

    // 3. Model selection
    const model = await p.select({
      message: "Model",
      options: [
        { value: "sonnet" as ModelAlias, label: "Sonnet", hint: "balanced" },
        { value: "haiku" as ModelAlias, label: "Haiku", hint: "fast & cheap" },
        { value: "opus" as ModelAlias, label: "Opus", hint: "strongest" },
      ],
    });
    if (isCancel(model)) bail();

    // 3b. Thinking variant (opencode only, with model-aware default)
    let variant: string | undefined;
    if (backend === "opencode") {
      const defaultThinking = THINKING_DEFAULTS[model as ModelAlias];
      const v = await p.select({
        message: "Thinking level",
        initialValue: defaultThinking,
        options: [
          { value: "minimal" as ThinkingLevel, label: "Minimal" },
          { value: "high" as ThinkingLevel, label: "High" },
          { value: "max" as ThinkingLevel, label: "Max" },
        ],
      });
      if (isCancel(v)) bail();
      variant = v as string;
    }

    // 4. Option count
    let count: number;
    if (args.count) {
      count = parseInt(args.count, 10);
      if (isNaN(count) || count < 1 || count > 15) {
        p.log.error("--count must be between 1 and 15.");
        bail();
      }
    } else {
      const countInput = await p.text({
        message: "How many options?",
        placeholder: "5",
        defaultValue: "5",
        validate(val) {
          const n = parseInt(val, 10);
          if (isNaN(n) || n < 1 || n > 15) return "Enter a number between 1 and 15";
        },
      });
      if (isCancel(countInput)) bail();
      count = parseInt(countInput as string, 10);
    }

    // 5. Optional context
    const userContext = await p.text({
      message: "Context for the AI " + pc.dim("(optional, Enter to skip)"),
      placeholder: "e.g. refactored auth flow, fixed edge case in parser...",
      defaultValue: "",
    });
    if (isCancel(userContext)) bail();

    // 6. Gather diff context
    const s = p.spinner();
    s.start("Gathering staged changes...");
    const diffContext = gatherDiffContext();
    s.stop("Context gathered.");

    // 7. Generate → Select → Action loop
    let refinement: string | undefined;
    let tweakBaseline: string | undefined;

    mainLoop: while (true) {
      // Build refinement context from tweak baseline if present
      let currentRefinement = refinement;
      if (tweakBaseline) {
        const tweakFeedback = await p.text({
          message: "How should the AI tweak this message?",
          placeholder: "e.g. shorter subject, focus on the API changes...",
        });
        if (isCancel(tweakFeedback)) bail();

        currentRefinement = `The user liked this message as a starting point:\n\n> ${tweakBaseline.replace(/\n/g, "\n> ")}\n\nTheir feedback: ${(tweakFeedback as string).trim()}\n\nGenerate ${count} new variations based on this baseline.`;
        tweakBaseline = undefined;
      }

      const genSpinner = p.spinner();
      const backendLabel = `${pc.cyan(backend)}/${pc.yellow(model)}`;
      const t0 = Date.now();
      genSpinner.start(`Generating via ${backendLabel}...`);

      const timer = setInterval(() => {
        const elapsed = ((Date.now() - t0) / 1000).toFixed(0);
        genSpinner.message(`Generating via ${backendLabel}... ${pc.dim(`${elapsed}s`)}`);
      }, 1000);

      let raw: string;
      try {
        raw = await invokeAI(backend, model, diffContext, userContext, count, variant, currentRefinement);
      } catch (err) {
        clearInterval(timer);
        genSpinner.stop("Generation failed.");
        p.log.error(
          err instanceof Error ? err.message : "Unknown error from AI backend.",
        );

        const retry = await p.confirm({ message: "Retry?" });
        if (isCancel(retry) || !retry) bail();
        continue;
      }

      clearInterval(timer);
      const elapsed = ((Date.now() - t0) / 1000).toFixed(1);
      genSpinner.stop(`Options generated. ${pc.dim(`(${elapsed}s)`)}`);

      const options = parseOptions(raw);

      if (options.length === 0) {
        p.log.warn("Could not parse AI response. Raw output:");
        console.log(pc.dim(raw));
        const retry = await p.confirm({ message: "Retry?" });
        if (isCancel(retry) || !retry) bail();
        refinement = undefined;
        continue;
      }

      // Custom multi-line select
      const pick = await commitSelect(options);
      if (isCancel(pick)) bail();

      if (pick === "regenerate") {
        // Refinement sub-prompt
        refinement = await promptRefinement();
        continue;
      }

      const chosen = options[pick as number];

      // Post-selection action
      const action = await promptPostAction();

      switch (action) {
        case "commit": {
          const message = toCommitMessage(chosen);
          runCommit(message, dryRun);
          break mainLoop;
        }
        case "edit": {
          const draft = toCommitMessage(chosen);
          const edited = editInEditor(draft);
          if (!edited) {
            p.log.warn("Empty message — aborting.");
            bail();
          }
          runCommit(edited, dryRun);
          break mainLoop;
        }
        case "tweak": {
          tweakBaseline = toCommitMessage(chosen);
          refinement = undefined;
          continue mainLoop;
        }
      }
    }

    p.outro(dryRun ? pc.yellow("Dry run complete.") : pc.green("Committed!"));
  },
});

runMain(main);
